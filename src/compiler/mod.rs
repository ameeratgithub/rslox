///
/// This module is responsible of taking source code, parse it and generate bytecode. This is a single phase compiler. It means it parses code and and generate bytecode in one step
/// Byte code is generated as soon as an expression has been parsed. This module shouldn't care about object values created at runtime. Like strings can be created at runtime and you can also specify a string as literal. They both should behave differently, and string created at runtime should be garbage collected.
///
use std::num::ParseFloatError;

use crate::{
    chunk::{Chunk, OpCode},
    compiler::{
        parser::{Parser, ParserError},
        precedence::{ParseRule, Precedence},
    },
    scanner::{
        Scanner,
        token::{Token, TokenType},
    },
    value::Value,
};

#[cfg(feature = "debug_trace_execution")]
use crate::debug::Debug;

pub mod parser;
pub mod precedence;

const UINT8_COUNT: usize = (u8::MAX as usize) + 1;

#[derive(Debug, Clone)]
pub struct Local {
    name: Token,
    depth: i32,
}

/// Custom Errors for compiler
#[derive(Debug)]
pub enum CompilerError {
    ParserError(ParserError),
    ExpressionError(String),
}

/// impl `Display` trait to show error nicely on console.
impl std::fmt::Display for CompilerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ParserError(error) => {
                write!(f, "{}", error)
            }
            Self::ExpressionError(error) => {
                write!(f, "{}", error)
            }
        }
    }
}

/// Data structure that handles compiler functionality, which includes parsing and generating bytecode
/// Compiler doesn't care about how to execute bytecode, it's the responsibility of the virtual machine.
/// It scans tokens on demand, which can reduce memory usage.
pub struct Compiler<'a> {
    /// Reference of the source code
    source: &'a str,
    /// Parser object to parse code on demand
    parser: Parser<'a>,
    /// Data structure to hold bytecode generated by compiler
    chunk: &'a mut Chunk,
    locals: [Option<Local>; UINT8_COUNT],
    local_count: i32,
    scope_depth: i32,
}

impl<'a> Compiler<'a> {
    /// Returns a fresh instance of `Compiler`
    pub fn new(source: &'a str, chunk: &'a mut Chunk) -> Self {
        // Create a scanner object from source code to scan tokens on demand
        let scanner: Scanner<'_> = Scanner::new(source);
        // Parser needs to scan tokens on demand, it'll need scanner object for that
        let parser = Parser::new(scanner);

        Self {
            parser,
            chunk,
            source,
            locals: [const { None }; UINT8_COUNT],
            scope_depth: 0,
            local_count: 0,
        }
    }

    // Responsible to generate byte code from source code
    pub fn compile(&mut self) -> Result<(), CompilerError> {
        // Consumes first token
        // Important because we look back and see previous tokens
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;
        // Iterate til the end of the file. If current token is `Eof`, loop will end.
        while !self.match_curr_ty(TokenType::Eof)? {
            // Process statements
            self.declaration()?;
        }

        self.end_compiler()?;

        Ok(())
    }

    /// Responsible to handle all top level statements and declarations
    fn declaration(&mut self) -> Result<(), CompilerError> {
        // If current token type is var, emit bytecode for variable declaration, otherwise proceed with other types of statements
        if self.match_curr_ty(TokenType::Var)? {
            // If token is variable declaration, generate bytecode to declare the variable
            self.var_declaration()?;
        } else {
            // Generate bytecode to process the statement
            self.statement()?;
        }

        Ok(())
    }

    /// Generates bytecode to declare a variable
    fn var_declaration(&mut self) -> Result<(), CompilerError> {
        // Get the index of variable name, stored in constant pool
        let global = self.parse_variable("Expected variable name")?;
        if self.match_curr_ty(TokenType::Equal)? {
            // Current token is equal, evaluate the expression on the right hand side, which will be pushed on VM's stack
            self.expression()?;
        } else {
            // No value has been assigned to the variable. Assign `Nil` by default, which will be pushed on VM's stack
            self.emit_byte(OpCode::OpNil as u8)?;
        }
        // Variable declaration and initialization has been parsed. Consume ';' from the end.
        self.parser
            .consume(TokenType::Semicolon, "Expected ';'")
            .map_err(|e| CompilerError::ParserError(e))?;

        // Define global variable
        self.define_variable(global)?;

        Ok(())
    }

    /// Parses variable and generates bytecode for variable name, returns variable name's index of constant pool
    fn parse_variable(&mut self, message: &str) -> Result<u8, CompilerError> {
        // Identifier, variable name in this case, would be consumed.
        self.parser
            .consume(TokenType::Identifier, message)
            .map_err(|e| CompilerError::ParserError(e))?;
        // After consumption, variable name is in previous token
        let prev_token = self.parser.previous.clone().ok_or_else(|| {
            let error = self.parser.error_at_previous("Expected variable name");
            CompilerError::ParserError(error)
        })?;

        self.declare_local_variable()?;
        if self.scope_depth > 0 {
            // Dummy table index
            return Ok(0);
        }

        // Generate bytecode for identifier token
        self.identifier_constant(&prev_token)
    }

    fn declare_local_variable(&mut self) -> Result<(), CompilerError> {
        if self.scope_depth == 0 {
            return Ok(());
        }

        let name = self.parser.previous.clone().ok_or_else(|| {
            CompilerError::ParserError(self.parser.error_at_previous("Variable name expected."))
        })?;

        for i in (0..self.local_count).rev() {
            let local = self.get_local_variable_ref(i as usize)?;
            if local.depth != -1 && local.depth < self.scope_depth {
                break;
            }

            if self.are_identifiers_equal(&name, &local.name) {
                let error = self
                    .parser
                    .error_at_previous("Already a variable with this name in this scope.");
                return Err(CompilerError::ParserError(error));
            }
        }
        self.add_local_variable(name)?;
        Ok(())
    }

    fn get_local_variable_ref(&self, index: usize) -> Result<&Local, CompilerError> {
        self.locals[index].as_ref().ok_or_else(|| {
            CompilerError::ParserError(self.parser.error_at_previous("Variable name expected."))
        })
    }

    fn are_identifiers_equal(&self, token_a: &Token, token_b: &Token) -> bool {
        if token_a.length != token_b.length {
            return false;
        }
        token_a.as_str(self.source) == token_b.as_str(self.source)
    }

    fn resolve_local(&self, name: &Token) -> Result<i32, CompilerError> {
        for i in (0..self.local_count).rev() {
            let local = self.get_local_variable_ref(i as usize)?;
            if self.are_identifiers_equal(name, &local.name) {
                if local.depth == -1 {
                    let error = self
                        .parser
                        .error_at_previous("Can't read local variable in its own initializer");
                    return Err(CompilerError::ParserError(error));
                }
                return Ok(i);
            }
        }
        Ok(-1)
    }

    fn add_local_variable(&mut self, name: Token) -> Result<(), CompilerError> {
        if self.local_count == UINT8_COUNT as i32 {
            let parser_error = self
                .parser
                .error_at_previous("Too many local variables in scope");
            return Err(CompilerError::ParserError(parser_error));
        }

        let local = Local { name, depth: -1 };

        self.locals[self.local_count as usize] = Some(local);
        self.local_count += 1;

        Ok(())
    }

    fn mark_variable_initialized(&mut self) -> Result<(), CompilerError> {
        let local = self.locals[(self.local_count - 1) as usize]
            .as_mut()
            .ok_or_else(|| {
                let err = self.parser.error_at_previous("Expected local variable");
                CompilerError::ParserError(err)
            })?;

        local.depth = self.scope_depth;
        Ok(())
    }
    /// Writes bytecode to define global variable
    fn define_variable(&mut self, global: u8) -> Result<(), CompilerError> {
        if self.scope_depth > 0 {
            self.mark_variable_initialized()?;
            return Ok(());
        }
        // Emits opcode and index of global variable
        self.emit_bytes(OpCode::OpDefineGlobal as u8, global)
    }

    /// Evaluates statements
    fn statement(&mut self) -> Result<(), CompilerError> {
        if self.match_curr_ty(TokenType::Print)? {
            self.print_statement()?;
        } else if self.match_curr_ty(TokenType::LeftBrace)? {
            self.begin_scope();
            self.block()?;
            self.end_scope()?;
        } else {
            self.expression_statement()?;
        }
        Ok(())
    }

    /// Evaluates expression statements. Result of expression statement is discarded at the end of the evaluation. These statements are executed for their side effects, not their produced results.
    fn expression_statement(&mut self) -> Result<(), CompilerError> {
        // Evaluate the expression
        self.expression()?;
        // Consume the ';' from the end of the expression
        self.parser
            .consume(TokenType::Semicolon, "Expect ';' after expression.")
            .map_err(|e| CompilerError::ParserError(e))?;
        // Discard the result, because it's not needed.
        self.emit_byte(OpCode::OpPop as u8)?;
        Ok(())
    }

    fn expression(&mut self) -> Result<(), CompilerError> {
        // Parse expression based on precedence
        self.parse_precedence(Precedence::Assignment)?;
        Ok(())
    }

    fn begin_scope(&mut self) {
        self.scope_depth += 1;
    }

    fn end_scope(&mut self) -> Result<(), CompilerError> {
        self.scope_depth -= 1;

        while self.local_count > 0
            && self
                .get_local_variable_ref((self.local_count - 1) as usize)?
                .depth
                > self.scope_depth
        {
            self.emit_byte(OpCode::OpPop as u8)?;
            self.local_count -= 1;
        }

        Ok(())
    }

    fn block(&mut self) -> Result<(), CompilerError> {
        while !self.check_current(TokenType::RightBrace) && !self.check_current(TokenType::Eof) {
            self.declaration()?;
        }

        self.parser
            .consume(TokenType::RightBrace, "Expected '}' after block.")
            .map_err(|e| CompilerError::ParserError(e))
    }

    fn number(&mut self, _: bool) -> Result<(), CompilerError> {
        // Get previous token, which should be a number
        let token = self
            .parser
            .previous
            .as_ref()
            .ok_or(CompilerError::ParserError(
                self.parser.error_at_previous("Expected Number, found None"),
            ))?;

        // Extract number from source code.
        let val = &self.source[token.start..token.start + token.length as usize];

        // Try to parse number to the `Value`
        let val: f64 = val.parse().map_err(|e: ParseFloatError| {
            CompilerError::ParserError(self.parser.error_at_previous(&e.to_string()))
        })?;

        // Write this in chunk
        self.emit_constant(val.into())?;

        Ok(())
    }

    fn grouping(&mut self, _: bool) -> Result<(), CompilerError> {
        // Initial '(' has already been consumed, so next we have to evaluate inner expression.
        // Recursive call to evaluate the inner expression
        self.expression()?;

        // When inner expression is evaluated/parsed, consume the right parenthesis
        self.parser
            .consume(TokenType::RightParen, "Expected ')' after expression.")
            .map_err(|e| CompilerError::ParserError(e))?;

        Ok(())
    }

    /// Returns type of the current token
    fn get_current_token_ty(&mut self) -> Result<TokenType, CompilerError> {
        Ok(self
            .parser
            .current
            .as_ref()
            .ok_or(CompilerError::ParserError(
                self.parser.error_at_current("Expected token"),
            ))?
            .ty)
    }

    /// Returns type of the previous token
    fn get_previous_token_ty(&mut self) -> Result<TokenType, CompilerError> {
        Ok(self
            .parser
            .previous
            .as_ref()
            .ok_or(CompilerError::ParserError(
                self.parser.error_at_previous("Expected token"),
            ))?
            .ty)
    }

    /// Executes instructions according to precedence.
    fn parse_precedence(&mut self, precedence: Precedence) -> Result<(), CompilerError> {
        // Parser already advanced one time, so this is second advance call
        // So in the case of `2+1`, parser would be at `+`
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;

        // Check if previous token has any prefix rule
        if let Some(prefix_rule) = ParseRule::get_parse_rule(self.get_previous_token_ty()?).prefix {
            // `can_assign` is used in `prefix_rule` of variables. It is being passed to other rules, infix and prefix, as well but it's being ignored there. This rule should be executed with `can_assign=true` when a variable is declared AND initialized. If it's not initialized, there's no assignment (`TokenType::Equal`) operator, and expression method shouldn't be called.
            let can_assign = precedence as u8 <= Precedence::Assignment as u8;
            // Prefix rule in an expression gets executed first
            prefix_rule(self, can_assign)?;

            // Repeat while precedence is lower than current token
            while precedence as u8
                <= ParseRule::get_parse_rule(self.get_current_token_ty()?).precedence as u8
            {
                // Consume token to get right operand
                self.parser
                    .advance()
                    .map_err(|e| CompilerError::ParserError(e))?;

                // It's the same operator who's precedence got compared.
                // After calling advance, it becomes previous token
                if let Some(infix_rule) =
                    ParseRule::get_parse_rule(self.get_previous_token_ty()?).infix
                {
                    // If operator has infix rule, execute it
                    infix_rule(self, can_assign)?;
                }

                // After the infix rule, like expression `a * b`, there shouldn't be any equal sign or `can_assign` should be false. This throws error when we right something like `a * b = c + d;`
                if can_assign && self.match_curr_ty(TokenType::Equal)? {
                    return Err(CompilerError::ExpressionError(
                        "Invalid assignment target".to_owned(),
                    ));
                }
            }
        } else {
            // Token should have an infix rule
            let err = self.parser.error_at_previous("Expected expression.");
            return Err(CompilerError::ParserError(err));
        }

        Ok(())
    }

    /// Writes byte code for binary instructions
    fn binary(&mut self, _: bool) -> Result<(), CompilerError> {
        // Get binary operator
        let operator = self.get_previous_token_ty()?;

        // Get the rule of operator
        let rule = ParseRule::get_parse_rule(operator);

        // Recursive call parse_precedence if some high priority operator should be
        // executed first. Priority is increased via `precedence + 1`. If next operator doesn't
        // have higher precedence, only prefix rule will get called and then function will return
        self.parse_precedence(Precedence::from((rule.precedence as u8) + 1))?;

        // Check which binary operator is this, and emit byte code accordingly
        match operator {
            TokenType::Plus => self.emit_byte(OpCode::OpAdd as u8)?,
            TokenType::Minus => self.emit_byte(OpCode::OpSubtract as u8)?,
            TokenType::Star => self.emit_byte(OpCode::OpMultiply as u8)?,
            TokenType::Slash => self.emit_byte(OpCode::OpDivide as u8)?,
            TokenType::BangEqual => self.emit_bytes(OpCode::OpEqual as u8, OpCode::OpNot as u8)?,
            TokenType::EqualEqual => self.emit_byte(OpCode::OpEqual as u8)?,
            TokenType::Greater => self.emit_byte(OpCode::OpGreater as u8)?,
            TokenType::GreaterEqual => {
                self.emit_bytes(OpCode::OpLess as u8, OpCode::OpNot as u8)?
            }
            TokenType::Less => self.emit_byte(OpCode::OpLess as u8)?,
            TokenType::LessEqual => {
                self.emit_bytes(OpCode::OpGreater as u8, OpCode::OpNot as u8)?
            }
            // There isn't any other binary operator allowed
            _ => unreachable!(),
        }

        Ok(())
    }

    /// Emits byte code for supported unary operators
    fn unary(&mut self, _: bool) -> Result<(), CompilerError> {
        // Get operator
        let operator = self.get_previous_token_ty()?;

        // Recursive call to get the operand
        // In normal case, bytes for the Number operand will get emitted
        self.parse_precedence(Precedence::Unary)?;

        match operator {
            // Writes byte code (OpNot) for bang operator,
            TokenType::Bang => self.emit_byte(OpCode::OpNot as u8)?,
            // Writes byte code (OpNegate) for minus operator,
            TokenType::Minus => self.emit_byte(OpCode::OpNegate as u8)?,
            // There is no unary operator other than Minus, in this language
            // So unary function shouldn't be called if the operator is other
            // than Minus
            _ => unreachable!(),
        }

        Ok(())
    }

    /// Generates bytecode for keywords that generate literal values
    fn literal(&mut self, _: bool) -> Result<(), CompilerError> {
        let operator = self.get_previous_token_ty()?;
        match operator {
            TokenType::False => self.emit_byte(OpCode::OpFalse as u8)?,
            TokenType::Nil => self.emit_byte(OpCode::OpNil as u8)?,
            TokenType::True => self.emit_byte(OpCode::OpTrue as u8)?,
            _ => unreachable!(),
        }

        Ok(())
    }

    fn string(&mut self, _: bool) -> Result<(), CompilerError> {
        let token = self.parser.previous.as_ref().ok_or_else(|| {
            CompilerError::ParserError(self.parser.error_at_previous("Expected token"))
        })?;
        // Skip the double quotes character '"'
        let start_index = token.start + 1;
        // Last index of token would be `length - 1`, and has ending double quotes
        // So, also skipping ending '"'
        let end_index = start_index + (token.length as usize - 2);
        // String value from source code is getting copied into virtual machine
        let str = self.source[start_index..end_index].to_owned();
        // Create a Value object from String
        let value = Value::from(str);
        // Emit that value as constant
        self.emit_constant(value)?;

        Ok(())
    }

    /// Evaluates the variable declaration and initialization
    fn variable(&mut self, can_assign: bool) -> Result<(), CompilerError> {
        let prev_token = self
            .parser
            .previous
            .as_ref()
            .ok_or_else(|| {
                CompilerError::ParserError(self.parser.error_at_previous("Expected previous token"))
            })?
            .clone();

        self.named_variable(&prev_token, can_assign)
    }

    fn named_variable(&mut self, name: &Token, can_assign: bool) -> Result<(), CompilerError> {
        // Generate the bytecode for identifier
        // let arg = self.identifier_constant(&name)?;

        let get_opcode: OpCode;
        let set_opcode: OpCode;

        let arg = self.resolve_local(name)?;
        let variable_offset;
        if arg != -1 {
            variable_offset = arg as u8;
            get_opcode = OpCode::OpGetLocal;
            set_opcode = OpCode::OpSetLocal;
        } else {
            variable_offset = self.identifier_constant(name)?;
            get_opcode = OpCode::OpGetGlobal;
            set_opcode = OpCode::OpSetGlobal;
        }

        if can_assign && self.match_curr_ty(TokenType::Equal)? {
            // Current variable can assign, and current token is `Equal`, evaluate the expression on the right
            self.expression()?;
            // Emit the OpCode to set global variable, alongside the variable name index.
            self.emit_bytes(set_opcode as u8, variable_offset)
        } else {
            // Can't assign, or current token is not `Equal`, parse it as reading the global variable
            self.emit_bytes(get_opcode as u8, variable_offset)
        }
    }

    /// Generates byte code for `print` statement
    fn print_statement(&mut self) -> Result<(), CompilerError> {
        // Print statement has been consumed. Just parse the expression
        self.expression()?;
        // Consume the ';' from the end of the statement
        self.parser
            .consume(TokenType::Semicolon, "Expected ';' after value.")
            .map_err(|e| CompilerError::ParserError(e))?;
        // Emit opcode for print
        self.emit_byte(OpCode::OpPrint as u8)?;
        Ok(())
    }

    /// Consume token if current token matches, and returns true. Otherwise returns false
    fn match_curr_ty(&mut self, ty: TokenType) -> Result<bool, CompilerError> {
        if !self.check_current(ty) {
            // Token doesn't match, return false
            return Ok(false);
        }
        // Token matches, consume token
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;
        Ok(true)
    }

    /// Checks if current token matches with desired token
    fn check_current(&self, ty: TokenType) -> bool {
        if let Some(token) = &self.parser.current {
            return token.ty == ty;
        }
        false
    }

    /// Gets the variable name from source code and adds that name into constant pool of bytecode
    fn identifier_constant(&mut self, name: &Token) -> Result<u8, CompilerError> {
        // Get name of the variable from source code and store as a string
        let name = name.as_str(self.source);
        // Make constant from variable name and get the index
        let constant_index = self.make_constant(name.into())?;
        Ok(constant_index)
    }

    /// Write a constant instruction and its index/offset in constant pool of the `chunk`
    fn emit_constant(&mut self, value: Value) -> Result<(), CompilerError> {
        // Add value to the constant pool and get the index
        let constant = self.make_constant(value)?;
        // Emit store bytecode for OpCode and offset/index of constant in constant pool
        self.emit_bytes(OpCode::OpConstant as u8, constant)?;
        Ok(())
    }

    /// Adds constant to constant pool and returns its index
    fn make_constant(&mut self, value: Value) -> Result<u8, CompilerError> {
        let constant = self.chunk.add_constant(value);
        // Only allows 256 constants to be stored in constant pool
        if constant > u8::MAX as usize {
            let err = self
                .parser
                .error_at_previous("Too many constants in one chunk");
            return Err(CompilerError::ParserError(err));
        }

        Ok(constant as u8)
    }

    /// Executes when all expressions are evaluated
    fn end_compiler(&mut self) -> Result<(), CompilerError> {
        self.emit_return()?;

        // Disassembles byte code to see what's going on
        #[cfg(feature = "debug_trace_execution")]
        Debug::dissassemble_chunk(&self.chunk, "code");

        Ok(())
    }

    /// Writes a byte to the `chunk`
    fn emit_byte(&mut self, byte: u8) -> Result<(), CompilerError> {
        // Getting parser.previous should always return a token.
        // So it's safe to unwrap
        let line = self
            .parser
            .previous
            .as_ref()
            .ok_or(CompilerError::ParserError(
                self.parser.error_at_previous("Expected token"),
            ))?
            .line;
        // Add byte with token's line
        self.chunk.write_chunk(byte, line);
        Ok(())
    }

    /// Writes OpReturn instruction at the end of the bytecode
    fn emit_return(&mut self) -> Result<(), CompilerError> {
        self.emit_byte(OpCode::OpReturn as u8)
    }

    /// Simply writes 2 bytes in order
    fn emit_bytes(&mut self, byte1: u8, byte2: u8) -> Result<(), CompilerError> {
        self.emit_byte(byte1)?;
        self.emit_byte(byte2)?;
        Ok(())
    }
}
