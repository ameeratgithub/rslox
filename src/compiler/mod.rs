///
/// This module is responsible of taking source code, parse it and generate bytecode. This is a single phase compiler. It means it parses code and and generate bytecode in one step
/// Byte code is generated as soon as an expression has been parsed. This module shouldn't care about object values created at runtime. Like strings can be created at runtime and you can also specify a string as literal. They both should behave differently, and string created at runtime should be garbage collected.
///
use std::num::ParseFloatError;

use crate::{
    chunk::{Chunk, OpCode},
    compiler::{
        parser::{Parser, ParserError},
        precedence::{ParseRule, Precedence},
    },
    scanner::{
        Scanner,
        token::{Token, TokenType},
    },
    value::Value,
};

#[cfg(feature = "debug_trace_execution")]
use crate::debug::Debug;

pub mod parser;
pub mod precedence;

const UINT8_COUNT: usize = (u8::MAX as usize) + 1;

#[derive(Debug, Clone)]
pub struct Local {
    name: Token,
    depth: i32,
}

/// Custom Errors for compiler
#[derive(Debug)]
pub enum CompilerError {
    ParserError(ParserError),
    ExpressionError(String),
}

/// impl `Display` trait to show error nicely on console.
impl std::fmt::Display for CompilerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ParserError(error) => {
                write!(f, "{}", error)
            }
            Self::ExpressionError(error) => {
                write!(f, "{}", error)
            }
        }
    }
}

/// Data structure that handles compiler functionality, which includes parsing and generating bytecode
/// Compiler doesn't care about how to execute bytecode, it's the responsibility of the virtual machine.
/// It scans tokens on demand, which can reduce memory usage.
pub struct Compiler<'a> {
    /// Reference of the source code
    source: &'a str,
    /// Parser object to parse code on demand
    parser: Parser<'a>,
    /// Data structure to hold bytecode generated by compiler
    chunk: &'a mut Chunk,
    locals: [Option<Local>; UINT8_COUNT],
    local_count: i32,
    scope_depth: i32,
}

impl<'a> Compiler<'a> {
    /// Returns a fresh instance of `Compiler`
    pub fn new(source: &'a str, chunk: &'a mut Chunk) -> Self {
        // Create a scanner object from source code to scan tokens on demand
        let scanner: Scanner<'_> = Scanner::new(source);
        // Parser needs to scan tokens on demand, it'll need scanner object for that
        let parser = Parser::new(scanner);

        Self {
            parser,
            chunk,
            source,
            locals: [const { None }; UINT8_COUNT],
            scope_depth: 0,
            local_count: 0,
        }
    }

    // Responsible to generate byte code from source code
    pub fn compile(&mut self) -> Result<(), CompilerError> {
        // Consumes first token
        // Important because we look back and see previous tokens
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;
        // Iterate til the end of the file. If current token is `Eof`, loop will end.
        while !self.match_curr_ty(TokenType::Eof)? {
            // Process statements
            self.declaration()?;
        }

        self.end_compiler()?;

        Ok(())
    }

    fn consume(&mut self, ty: TokenType, message: &str) -> Result<(), CompilerError> {
        self.parser
            .consume(ty, message)
            .map_err(|e| CompilerError::ParserError(e))
    }

    /// Responsible to handle all top level statements and declarations
    fn declaration(&mut self) -> Result<(), CompilerError> {
        // If current token type is var, emit bytecode for variable declaration, otherwise proceed with other types of statements
        if self.match_curr_ty(TokenType::Var)? {
            // If token is variable declaration, generate bytecode to declare the variable
            self.var_declaration()?;
        } else {
            // Generate bytecode to process the statement
            self.statement()?;
        }

        Ok(())
    }

    /// Generates bytecode to declare a variable
    fn var_declaration(&mut self) -> Result<(), CompilerError> {
        // Get the index of variable name, stored in constant pool
        let global = self.parse_variable("Expected variable name")?;
        if self.match_curr_ty(TokenType::Equal)? {
            // Current token is equal, evaluate the expression on the right hand side, which will be pushed on VM's stack
            self.expression()?;
        } else {
            // No value has been assigned to the variable. Assign `Nil` by default, which will be pushed on VM's stack
            self.emit_byte(OpCode::OpNil as u8)?;
        }
        // Variable declaration and initialization has been parsed. Consume ';' from the end.
        self.consume(TokenType::Semicolon, "Expected ';'")?;

        // Define global variable
        self.define_variable(global)?;

        Ok(())
    }

    /// Parses variable and generates bytecode for variable name, returns variable name's index of constant pool
    fn parse_variable(&mut self, message: &str) -> Result<u8, CompilerError> {
        // Identifier, variable name in this case, would be consumed.
        self.consume(TokenType::Identifier, message)?;
        // After consumption, variable name is in previous token
        let prev_token = self
            .parser
            .previous
            .clone()
            .ok_or_else(|| self.construct_token_error(false, "Expected variable name"))?;

        self.declare_local_variable()?;
        if self.scope_depth > 0 {
            // Dummy table index
            return Ok(0);
        }

        // Generate bytecode for identifier token
        self.identifier_constant(&prev_token)
    }

    fn declare_local_variable(&mut self) -> Result<(), CompilerError> {
        if self.scope_depth == 0 {
            return Ok(());
        }

        let error = self.construct_token_error(false, "Variable name expected.");

        let name = self.parser.previous.clone().ok_or(error)?;

        for i in (0..self.local_count).rev() {
            let scope_depth = self.scope_depth;
            let local = self.get_local_variable_ref(i as usize)?;
            if local.depth != -1 && local.depth < scope_depth {
                break;
            }
            let name = &local.name.clone();
            if self.are_identifiers_equal(&name, name) {
                return Err(self.construct_token_error(
                    false,
                    "Already a variable with this name in this scope.",
                ));
            }
        }
        self.add_local_variable(name)?;
        Ok(())
    }

    fn get_local_variable_ref(&mut self, index: usize) -> Result<&Local, CompilerError> {
        let err_message = self.construct_token_error(false, "Variable name expected.");
        self.locals[index].as_ref().ok_or(err_message)
    }

    fn are_identifiers_equal(&self, token_a: &Token, token_b: &Token) -> bool {
        if token_a.length != token_b.length {
            return false;
        }
        token_a.as_str(self.source) == token_b.as_str(self.source)
    }

    fn resolve_local(&mut self, name: &Token) -> Result<i32, CompilerError> {
        for i in (0..self.local_count).rev() {
            let local = self.get_local_variable_ref(i as usize)?.clone();
            if self.are_identifiers_equal(name, &local.name) {
                if local.depth == -1 {
                    return Err(self.construct_token_error(
                        false,
                        "Can't read local variable in its own initializer",
                    ));
                }
                return Ok(i);
            }
        }
        Ok(-1)
    }

    fn add_local_variable(&mut self, name: Token) -> Result<(), CompilerError> {
        if self.local_count == UINT8_COUNT as i32 {
            return Err(self.construct_token_error(false, "Too many local variables in scope"));
        }

        let local = Local { name, depth: -1 };

        self.locals[self.local_count as usize] = Some(local);
        self.local_count += 1;

        Ok(())
    }

    fn mark_variable_initialized(&mut self) -> Result<(), CompilerError> {
        let error = self.construct_token_error(false, "Expected local variable");
        let local = self.locals[(self.local_count - 1) as usize]
            .as_mut()
            .ok_or(error)?;

        local.depth = self.scope_depth;
        Ok(())
    }

    /// Writes bytecode to define global variable
    fn define_variable(&mut self, global: u8) -> Result<(), CompilerError> {
        if self.scope_depth > 0 {
            self.mark_variable_initialized()?;
            return Ok(());
        }
        // Emits opcode and index of global variable
        self.emit_bytes(OpCode::OpDefineGlobal as u8, global)
    }

    /// Evaluates statements
    fn statement(&mut self) -> Result<(), CompilerError> {
        
        if self.match_curr_ty(TokenType::Print)? {
            self.print_statement()?;
        } else if self.match_curr_ty(TokenType::For)? {
            self.for_statement()?;
        } else if self.match_curr_ty(TokenType::If)? {
            self.if_statement()?;
        } else if self.match_curr_ty(TokenType::While)? {
            self.while_statement()?;
        } else if self.match_curr_ty(TokenType::LeftBrace)? {
            self.begin_scope();
            self.block()?;
            self.end_scope()?;
        } else {
            self.expression_statement()?;
        }
        Ok(())
    }

    fn if_statement(&mut self) -> Result<(), CompilerError> {
        // 'if' token already consumed, now consume '('
        self.consume(TokenType::LeftParen, "Expected '(' after 'if'")?;
        // Evaluate condition expression and put the result on stack
        self.expression()?;
        // Consume the ')', after evaluation
        self.consume(TokenType::RightParen, "Expected ')' after condition")?;
        // If condition fails, then we'll need to skip the 'then' block. For this purpose, 'OpJumpIfFalse' needs to be emitted with distance/number of bytes we need to skip. To skip 65,535 bytes, we need to reserve two bytes. `emit_jump` will also emit these two place holder bytes alongside the OpCode.
        let then_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        // Emit opcode to pop the condition if the condition is true. This is important before emitting the bytecode for statements of if block.
        self.emit_byte(OpCode::OpPop as u8)?;
        // Evaluate the 'then' block
        self.statement()?;
        // Emit instructions for jumping to a specific position. Currently will contain placeholder bytes alongside the `OpJump` opcode
        let else_jump = self.emit_jump(OpCode::OpJump as u8)?;
        // `then_jump` will get patched. It means, we have evaluated the 'if' block code, we'll update the distance bytes, i.e. how far we actually need to jump when 'if' condition fails
        // Till now, we've evaluated and generated byte code for 'if' (3 bytes), 'if block' (gets executed when condition is true), and 'else' (3 bytes). When 'if' condition is false, it will skip else bytecode. It's all linear array of bytes, so we will skip right after `else`'s 3 bytes.
        self.patch_jump(then_jump)?;
        // Assuming if condition is false, and code is jumped to after `else`'s 3 bytes, we need to pop the condition result from the stack.
        self.emit_byte(OpCode::OpPop as u8)?;
        // Evaluate the else block
        if self.match_curr_ty(TokenType::Else)? {
            self.statement()?;
        }
        // Else jump should only be patched after evaluation of the else block. No `OpPop` needed because else doesn't have any condition
        self.patch_jump(else_jump)?;

        Ok(())
    }

    fn while_statement(&mut self) -> Result<(), CompilerError> {
        let loop_start = self.chunk.code.len();
        self.consume(TokenType::LeftParen, "Expect '(' after 'while'")?;
        self.expression()?;
        self.consume(TokenType::RightParen, "Expect ')' after condition")?;

        let exit_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        self.emit_byte(OpCode::OpPop as u8)?;
        self.statement()?;
        self.emit_loop(loop_start)?;

        self.patch_jump(exit_jump)?;
        self.emit_byte(OpCode::OpPop as u8)
    }

    fn for_statement(&mut self) -> Result<(), CompilerError> {
        self.begin_scope();
        self.consume(TokenType::LeftParen, "Expected '(' after 'for'.")?;

        if self.match_curr_ty(TokenType::Semicolon)? {
            // No initializer
        } else if self.match_curr_ty(TokenType::Var)? {
            self.var_declaration()?;
        } else {
            self.expression_statement()?;
        }

        let mut loop_start = self.chunk.code.len();

        let mut exit_jump: isize = -1;
        if !self.match_curr_ty(TokenType::Semicolon)? {
            self.expression()?;
            self.consume(TokenType::Semicolon, "Expected ';' after loop condition")?;
            exit_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)? as isize;
            self.emit_byte(OpCode::OpPop as u8)?;
        }

        if !self.match_curr_ty(TokenType::RightParen)? {
            let body_jump = self.emit_jump(OpCode::OpJump as u8)?;
            let increment_start = self.chunk.code.len();
            self.expression()?;
            self.emit_byte(OpCode::OpPop as u8)?;
            self.consume(TokenType::RightParen, "Expected ')' after for clause.")?;

            self.emit_loop(loop_start)?;
            loop_start = increment_start;
            self.patch_jump(body_jump)?;
        }

        self.statement()?;
        self.emit_loop(loop_start)?;

        if exit_jump != -1 {
            self.patch_jump(exit_jump as usize)?;
            self.emit_byte(OpCode::OpPop as u8)?;
        }

        self.end_scope()
    }

    /// Evaluates expression statements. Result of expression statement is discarded at the end of the evaluation. These statements are executed for their side effects, not their produced results.
    fn expression_statement(&mut self) -> Result<(), CompilerError> {
        // Evaluate the expression
        self.expression()?;
        // Consume the ';' from the end of the expression
        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;
        // Discard the result, because it's not needed.
        self.emit_byte(OpCode::OpPop as u8)?;
        Ok(())
    }

    fn expression(&mut self) -> Result<(), CompilerError> {
        // Parse expression based on precedence
        self.parse_precedence(Precedence::Assignment)?;
        Ok(())
    }

    fn begin_scope(&mut self) {
        self.scope_depth += 1;
    }

    fn end_scope(&mut self) -> Result<(), CompilerError> {
        self.scope_depth -= 1;

        while self.local_count > 0
            && self
                .get_local_variable_ref((self.local_count - 1) as usize)?
                .depth
                > self.scope_depth
        {
            self.emit_byte(OpCode::OpPop as u8)?;
            self.local_count -= 1;
        }

        Ok(())
    }

    fn block(&mut self) -> Result<(), CompilerError> {
        while !self.check_current(TokenType::RightBrace) && !self.check_current(TokenType::Eof) {
            self.declaration()?;
        }

        self.consume(TokenType::RightBrace, "Expected '}' after block.")
    }

    fn number(&mut self, _: bool) -> Result<(), CompilerError> {
        let error = self.construct_token_error(false, "Expected Number, found None");
        // Get previous token, which should be a number
        let token = self.parser.previous.as_ref().ok_or(error)?;
        // Extract number from source code.
        let val = &self.source[token.start..token.start + token.length as usize];
        // Try to parse number to the `Value`
        let val: f64 = val
            .parse()
            .map_err(|e: ParseFloatError| self.construct_token_error(false, &e.to_string()))?;

        // Write this in chunk
        self.emit_constant(val.into())?;

        Ok(())
    }

    fn grouping(&mut self, _: bool) -> Result<(), CompilerError> {
        // Initial '(' has already been consumed, so next we have to evaluate inner expression.
        // Recursive call to evaluate the inner expression
        self.expression()?;

        // When inner expression is evaluated/parsed, consume the right parenthesis
        self.consume(TokenType::RightParen, "Expected ')' after expression.")?;

        Ok(())
    }

    /// Returns type of the current token
    fn get_current_token_ty(&mut self) -> Result<TokenType, CompilerError> {
        let error = self.construct_token_error(true, "Expected token");
        Ok(self.parser.current.as_ref().ok_or(error)?.ty)
    }

    /// Returns type of the previous token
    fn get_previous_token_ty(&mut self) -> Result<TokenType, CompilerError> {
        let error = self.construct_token_error(false, "Expected token");
        Ok(self.parser.previous.as_ref().ok_or(error)?.ty)
    }

    /// Executes instructions according to precedence.
    fn parse_precedence(&mut self, precedence: Precedence) -> Result<(), CompilerError> {
        // Parser already advanced one time, so this is second advance call
        // So in the case of `2+1`, parser would be at `+`
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;

        // Check if previous token has any prefix rule
        if let Some(prefix_rule) = ParseRule::get_parse_rule(self.get_previous_token_ty()?).prefix {
            // `can_assign` is used in `prefix_rule` of variables. It is being passed to other rules, infix and prefix, as well but it's being ignored there. This rule should be executed with `can_assign=true` when a variable is declared AND initialized. If it's not initialized, there's no assignment (`TokenType::Equal`) operator, and expression method shouldn't be called.
            let can_assign = precedence as u8 <= Precedence::Assignment as u8;
            // Prefix rule in an expression gets executed first
            prefix_rule(self, can_assign)?;

            // Repeat while precedence is lower than current token
            while precedence as u8
                <= ParseRule::get_parse_rule(self.get_current_token_ty()?).precedence as u8
            {
                // Consume token to get right operand
                self.parser
                    .advance()
                    .map_err(|e| CompilerError::ParserError(e))?;

                // It's the same operator who's precedence got compared.
                // After calling advance, it becomes previous token
                if let Some(infix_rule) =
                    ParseRule::get_parse_rule(self.get_previous_token_ty()?).infix
                {
                    // If operator has infix rule, execute it
                    infix_rule(self, can_assign)?;
                }

                // After the infix rule, like expression `a * b`, there shouldn't be any equal sign or `can_assign` should be false. This throws error when we right something like `a * b = c + d;`
                if can_assign && self.match_curr_ty(TokenType::Equal)? {
                    return Err(CompilerError::ExpressionError(
                        "Invalid assignment target".to_owned(),
                    ));
                }
            }
        } else {
            // Token should have an infix rule
            return Err(self.construct_token_error(false, "Expected expression."));
        }

        Ok(())
    }

    // Performs the logical 'AND' operation between two boolean values.
    fn logical_and(&mut self, _: bool) -> Result<(), CompilerError> {
        // Left hand expression has already been evaluated and result would be on stack.
        // So if that result is false, just emit jump, as we don't need to evaluate the second condition.
        let end_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        // Pop the result from the stack
        self.emit_byte(OpCode::OpPop as u8)?;
        // Evaluate right hand expression with precedence of `And`
        self.parse_precedence(Precedence::And)?;

        // Calculate the jump distance. If first condition is false, it will jump over the bytes of subsequent conditions.
        self.patch_jump(end_jump)
    }
    // Performs the logical 'OR' operation between two boolean values.
    fn logical_or(&mut self, _: bool) -> Result<(), CompilerError> {
        // Left expression got evaluated, and is on the stack.
        // If that left expression is false, we need to evaluate the right expression.
        let else_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        // If left expression is true, we'll need to jump straight to the 'then' block, without checking any other condition
        let end_jump = self.emit_jump(OpCode::OpJump as u8)?;
        // This will skip to the remaining expression, if the first expression is false.
        self.patch_jump(else_jump)?;
        // Pop the result of evaluation of expression from the stack
        self.emit_byte(OpCode::OpPop as u8)?;
        // Parse the right hand side with `Precedence::Or`
        self.parse_precedence(Precedence::Or)?;
        // Patch the jump to go to the 'then' block.
        self.patch_jump(end_jump)
    }

    /// Writes byte code for binary instructions
    fn binary(&mut self, _: bool) -> Result<(), CompilerError> {
        // Get binary operator
        let operator = self.get_previous_token_ty()?;

        // Get the rule of operator
        let rule = ParseRule::get_parse_rule(operator);

        // Recursive call parse_precedence if some high priority operator should be
        // executed first. Priority is increased via `precedence + 1`. If next operator doesn't
        // have higher precedence, only prefix rule will get called and then function will return
        self.parse_precedence(Precedence::from((rule.precedence as u8) + 1))?;

        // Check which binary operator is this, and emit byte code accordingly
        match operator {
            TokenType::Plus => self.emit_byte(OpCode::OpAdd as u8)?,
            TokenType::Minus => self.emit_byte(OpCode::OpSubtract as u8)?,
            TokenType::Star => self.emit_byte(OpCode::OpMultiply as u8)?,
            TokenType::Slash => self.emit_byte(OpCode::OpDivide as u8)?,
            TokenType::BangEqual => self.emit_bytes(OpCode::OpEqual as u8, OpCode::OpNot as u8)?,
            TokenType::EqualEqual => self.emit_byte(OpCode::OpEqual as u8)?,
            TokenType::Greater => self.emit_byte(OpCode::OpGreater as u8)?,
            TokenType::GreaterEqual => {
                self.emit_bytes(OpCode::OpLess as u8, OpCode::OpNot as u8)?
            }
            TokenType::Less => self.emit_byte(OpCode::OpLess as u8)?,
            TokenType::LessEqual => {
                self.emit_bytes(OpCode::OpGreater as u8, OpCode::OpNot as u8)?
            }
            // There isn't any other binary operator allowed
            _ => unreachable!(),
        }

        Ok(())
    }

    /// Emits byte code for supported unary operators
    fn unary(&mut self, _: bool) -> Result<(), CompilerError> {
        // Get operator
        let operator = self.get_previous_token_ty()?;

        // Recursive call to get the operand
        // In normal case, bytes for the Number operand will get emitted
        self.parse_precedence(Precedence::Unary)?;

        match operator {
            // Writes byte code (OpNot) for bang operator,
            TokenType::Bang => self.emit_byte(OpCode::OpNot as u8)?,
            // Writes byte code (OpNegate) for minus operator,
            TokenType::Minus => self.emit_byte(OpCode::OpNegate as u8)?,
            // There is no unary operator other than Minus, in this language
            // So unary function shouldn't be called if the operator is other
            // than Minus
            _ => unreachable!(),
        }

        Ok(())
    }

    /// Generates bytecode for keywords that generate literal values
    fn literal(&mut self, _: bool) -> Result<(), CompilerError> {
        let operator = self.get_previous_token_ty()?;
        match operator {
            TokenType::False => self.emit_byte(OpCode::OpFalse as u8)?,
            TokenType::Nil => self.emit_byte(OpCode::OpNil as u8)?,
            TokenType::True => self.emit_byte(OpCode::OpTrue as u8)?,
            _ => unreachable!(),
        }

        Ok(())
    }

    fn string(&mut self, _: bool) -> Result<(), CompilerError> {
        let error = self.construct_token_error(false, "Expected token");
        let token = self.parser.previous.as_ref().ok_or(error)?;
        // Skip the double quotes character '"'
        let start_index = token.start + 1;
        // Last index of token would be `length - 1`, and has ending double quotes
        // So, also skipping ending '"'
        let end_index = start_index + (token.length as usize - 2);
        // String value from source code is getting copied into virtual machine
        let str = self.source[start_index..end_index].to_owned();
        // Create a Value object from String
        let value = Value::from(str);
        // Emit that value as constant
        self.emit_constant(value)?;

        Ok(())
    }

    /// Evaluates the variable declaration and initialization
    fn variable(&mut self, can_assign: bool) -> Result<(), CompilerError> {
        let error = self.construct_token_error(false, "Expected previous token");
        let prev_token = self.parser.previous.as_ref().ok_or(error)?.clone();
        self.named_variable(&prev_token, can_assign)
    }

    fn named_variable(&mut self, name: &Token, can_assign: bool) -> Result<(), CompilerError> {
        // Generate the bytecode for identifier
        // let arg = self.identifier_constant(&name)?;

        let get_opcode: OpCode;
        let set_opcode: OpCode;

        let arg = self.resolve_local(name)?;
        let variable_offset;
        if arg != -1 {
            variable_offset = arg as u8;
            get_opcode = OpCode::OpGetLocal;
            set_opcode = OpCode::OpSetLocal;
        } else {
            variable_offset = self.identifier_constant(name)?;
            get_opcode = OpCode::OpGetGlobal;
            set_opcode = OpCode::OpSetGlobal;
        }

        if can_assign && self.match_curr_ty(TokenType::Equal)? {
            // Current variable can assign, and current token is `Equal`, evaluate the expression on the right
            self.expression()?;
            // Emit the OpCode to set global variable, alongside the variable name index.
            self.emit_bytes(set_opcode as u8, variable_offset)
        } else {
            // Can't assign, or current token is not `Equal`, parse it as reading the global variable
            self.emit_bytes(get_opcode as u8, variable_offset)
        }
    }

    /// Generates byte code for `print` statement
    fn print_statement(&mut self) -> Result<(), CompilerError> {
        // Print statement has been consumed. Just parse the expression
        self.expression()?;
        // Consume the ';' from the end of the statement
        self.consume(TokenType::Semicolon, "Expected ';' after value.")?;
        // Emit opcode for print
        self.emit_byte(OpCode::OpPrint as u8)?;
        Ok(())
    }

    /// Consume token if current token matches, and returns true. Otherwise returns false
    fn match_curr_ty(&mut self, ty: TokenType) -> Result<bool, CompilerError> {
        if !self.check_current(ty) {
            // Token doesn't match, return false
            return Ok(false);
        }
        // Token matches, consume token
        self.parser
            .advance()
            .map_err(|e| CompilerError::ParserError(e))?;
        Ok(true)
    }

    /// Checks if current token matches with desired token
    fn check_current(&self, ty: TokenType) -> bool {
        if let Some(token) = &self.parser.current {
            return token.ty == ty;
        }
        false
    }

    /// Gets the variable name from source code and adds that name into constant pool of bytecode
    fn identifier_constant(&mut self, name: &Token) -> Result<u8, CompilerError> {
        // Get name of the variable from source code and store as a string
        let name = name.as_str(self.source);
        // Make constant from variable name and get the index
        let constant_index = self.make_constant(name.into())?;
        Ok(constant_index)
    }

    /// Write a constant instruction and its index/offset in constant pool of the `chunk`
    fn emit_constant(&mut self, value: Value) -> Result<(), CompilerError> {
        // Add value to the constant pool and get the index
        let constant = self.make_constant(value)?;
        // Emit store bytecode for OpCode and offset/index of constant in constant pool
        self.emit_bytes(OpCode::OpConstant as u8, constant)?;
        Ok(())
    }

    fn emit_jump(&mut self, instruction: u8) -> Result<usize, CompilerError> {
        self.emit_byte(instruction)?;
        self.emit_byte(0xff)?;
        self.emit_byte(0xff)?;
        // Will point to first byte after instruction
        let offset = self.chunk.code.len() - 2;
        Ok(offset)
    }

    fn emit_loop(&mut self, loop_start: usize) -> Result<(), CompilerError> {
        self.emit_byte(OpCode::OpLoop as u8)?;
        let offset = self.chunk.code.len() - loop_start + 2;
        if offset > u16::MAX as usize {
            let err = self.construct_token_error(false, "Loop body too large");
            return Err(err);
        }
        let offset_bytes = u16::to_be_bytes(offset as u16);
        self.emit_byte(offset_bytes[0])?;
        self.emit_byte(offset_bytes[1])
    }

    fn patch_jump(&mut self, offset: usize) -> Result<(), CompilerError> {
        // Offset is first byte after `OpIfFalse` instruction, excluding 'then' block
        // `chunk.code` contains bytecode after executing 'then' block
        // So if failed, we want to jump to after 'then' block
        // -2 is important to calculate relative distance.
        // Consider following scenario:
        // 1. `if` instruction index: 9, code length: 10
        // 2. Two place holder bytes emitted, code length: 12
        // 3. Offset = code length - 2 = 10, which is first byte after `if` instruction
        // 4. `then` block compiled, let's say code length = 50
        // 5. code length - offset = 50 - 10 = 40
        // 6. offset is of first byte after instruction, so these are included right now in jump position calculation
        // 7. if code length is 50, then our then block should be of 38 bytes. Why? our code length was 12 when two place holder bytes were emitted. 12 + 38 = 50.
        // 8. to correctly calculate that jump position, we also need to subtract 2 from code length
        let jump = self.chunk.code.len() - offset - 2;
        if jump > (u16::MAX as usize) {
            return Err(self.construct_token_error(false, "Too much code to jump over"));
        }
        // Jump is 32-bit, so we want to extract 2nd least significant byte.
        // jump>>8 will discard the least-significant byte and will make 2nd least significant, a least significant one.
        // Because our result is in least significant byte now, we will 'mask' our byte, by making essentialy all other bytes, zeros.
        let jump_bytes = (jump as u16).to_be_bytes();
        self.chunk.code[offset as usize] = jump_bytes[0];
        // We've used our 2nd least significant byte, so we'll use least significant byte. It's already least significant, no need to right shift. Just set all other bytes to zeros, by masking.
        self.chunk.code[offset as usize + 1] = jump_bytes[1];
        Ok(())
    }

    /// Adds constant to constant pool and returns its index
    fn make_constant(&mut self, value: Value) -> Result<u8, CompilerError> {
        let constant = self.chunk.add_constant(value);
        // Only allows 256 constants to be stored in constant pool
        if constant > u8::MAX as usize {
            return Err(self.construct_token_error(false, "Too many constants in one chunk"));
        }
        Ok(constant as u8)
    }

    /// Executes when all expressions are evaluated
    fn end_compiler(&mut self) -> Result<(), CompilerError> {
        self.emit_return()?;

        // Disassembles byte code to see what's going on
        #[cfg(feature = "debug_trace_execution")]
        Debug::dissassemble_chunk(&self.chunk, "code");

        Ok(())
    }

    /// Writes a byte to the `chunk`
    fn emit_byte(&mut self, byte: u8) -> Result<(), CompilerError> {
        let error = self.construct_token_error(false, "Expected token");
        let line = self.parser.previous.as_ref().ok_or(error)?.line;
        // Add byte with token's line
        self.chunk.write_chunk(byte, line);
        Ok(())
    }

    /// Writes OpReturn instruction at the end of the bytecode
    fn emit_return(&mut self) -> Result<(), CompilerError> {
        self.emit_byte(OpCode::OpReturn as u8)
    }

    /// Simply writes 2 bytes in order
    fn emit_bytes(&mut self, byte1: u8, byte2: u8) -> Result<(), CompilerError> {
        self.emit_byte(byte1)?;
        self.emit_byte(byte2)?;
        Ok(())
    }

    fn construct_token_error(&mut self, is_current: bool, message: &str) -> CompilerError {
        let error = if is_current {
            self.parser.error_at_current(message)
        } else {
            self.parser.error_at_previous(message)
        };
        CompilerError::ParserError(error)
    }
}
