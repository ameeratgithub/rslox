use crate::{
    chunk::OpCode,
    compiler::{CompilationContext, errors::CompilerError},
    scanner::token::TokenType,
};

impl<'a> CompilationContext<'a> {
    /// Evaluates statements
    pub(super) fn statement(&mut self) -> Result<(), CompilerError> {
        if self.match_curr_ty(TokenType::Print)? {
            self.print_statement()?;
        } else if self.match_curr_ty(TokenType::For)? {
            self.for_statement()?;
        } else if self.match_curr_ty(TokenType::If)? {
            self.if_statement()?;
        } else if self.match_curr_ty(TokenType::Return)? {
            self.return_statement()?;
        } else if self.match_curr_ty(TokenType::While)? {
            self.while_statement()?;
        } else if self.match_curr_ty(TokenType::LeftBrace)? {
            self.begin_scope();
            self.block()?;
            self.end_scope()?;
        } else {
            self.expression_statement()?;
        }
        Ok(())
    }

    fn if_statement(&mut self) -> Result<(), CompilerError> {
        // 'if' token already consumed, now consume '('
        self.consume(TokenType::LeftParen, "Expected '(' after 'if'")?;
        // Evaluate condition expression and put the result on stack
        self.expression()?;
        // Consume the ')', after evaluation
        self.consume(TokenType::RightParen, "Expected ')' after condition")?;
        // If condition fails, then we'll need to skip the 'then' block. For this purpose, 'OpJumpIfFalse' needs to be emitted with distance/number of bytes we need to skip. To skip 65,535 bytes, we need to reserve two bytes. `emit_jump` will also emit these two place holder bytes alongside the OpCode.
        let then_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        // Emit opcode to pop the condition if the condition is true. This is important before emitting the bytecode for statements of if block.
        self.emit_byte(OpCode::OpPop as u8)?;
        // Evaluate the 'then' block
        self.statement()?;
        // Emit instructions for jumping to a specific position. Currently will contain placeholder bytes alongside the `OpJump` opcode
        let else_jump = self.emit_jump(OpCode::OpJump as u8)?;
        // `then_jump` will get patched. It means, we have evaluated the 'if' block code, we'll update the distance bytes, i.e. how far we actually need to jump when 'if' condition fails
        // Till now, we've evaluated and generated byte code for 'if' (3 bytes), 'if block' (gets executed when condition is true), and 'else' (3 bytes). When 'if' condition is false, it will skip else bytecode. It's all linear array of bytes, so we will skip right after `else`'s 3 bytes.
        self.patch_jump(then_jump)?;
        // Assuming if condition is false, and code is jumped to after `else`'s 3 bytes, we need to pop the condition result from the stack.
        self.emit_byte(OpCode::OpPop as u8)?;
        // Evaluate the else block
        if self.match_curr_ty(TokenType::Else)? {
            self.statement()?;
        }
        // Else jump should only be patched after evaluation of the else block. No `OpPop` needed because else doesn't have any condition
        self.patch_jump(else_jump)?;

        Ok(())
    }

    fn while_statement(&mut self) -> Result<(), CompilerError> {
        let loop_start = self.compiler().chunk().code.len();
        self.consume(TokenType::LeftParen, "Expect '(' after 'while'")?;
        self.expression()?;
        self.consume(TokenType::RightParen, "Expect ')' after condition")?;

        let exit_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)?;
        self.emit_byte(OpCode::OpPop as u8)?;
        self.statement()?;
        self.emit_loop(loop_start)?;

        self.patch_jump(exit_jump)?;
        self.emit_byte(OpCode::OpPop as u8)
    }

    fn for_statement(&mut self) -> Result<(), CompilerError> {
        self.begin_scope();
        self.consume(TokenType::LeftParen, "Expected '(' after 'for'.")?;

        if self.match_curr_ty(TokenType::Semicolon)? {
            // No initializer
        } else if self.match_curr_ty(TokenType::Var)? {
            self.var_declaration()?;
        } else {
            self.expression_statement()?;
        }

        let mut loop_start = self.compiler().chunk().code.len();

        let mut exit_jump: isize = -1;
        if !self.match_curr_ty(TokenType::Semicolon)? {
            self.expression()?;
            self.consume(TokenType::Semicolon, "Expected ';' after loop condition")?;
            exit_jump = self.emit_jump(OpCode::OpJumpIfFalse as u8)? as isize;
            self.emit_byte(OpCode::OpPop as u8)?;
        }

        if !self.match_curr_ty(TokenType::RightParen)? {
            let body_jump = self.emit_jump(OpCode::OpJump as u8)?;
            let increment_start = self.compiler().chunk().code.len();
            self.expression()?;
            self.emit_byte(OpCode::OpPop as u8)?;
            self.consume(TokenType::RightParen, "Expected ')' after for clause.")?;

            self.emit_loop(loop_start)?;
            loop_start = increment_start;
            self.patch_jump(body_jump)?;
        }

        self.statement()?;
        self.emit_loop(loop_start)?;

        if exit_jump != -1 {
            self.patch_jump(exit_jump as usize)?;
            self.emit_byte(OpCode::OpPop as u8)?;
        }

        self.end_scope()
    }

    /// Evaluates expression statements. Result of expression statement is discarded at the end of the evaluation. These statements are executed for their side effects, not their produced results.
    fn expression_statement(&mut self) -> Result<(), CompilerError> {
        // Evaluate the expression
        self.expression()?;
        // Consume the ';' from the end of the expression
        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;
        // Discard the result, because it's not needed.
        self.emit_byte(OpCode::OpPop as u8)?;
        Ok(())
    }

    /// Generates byte code for `print` statement
    fn print_statement(&mut self) -> Result<(), CompilerError> {
        // Print statement has been consumed. Just parse the expression
        self.expression()?;
        // Consume the ';' from the end of the statement
        self.consume(TokenType::Semicolon, "Expected ';' after value.")?;
        // Emit opcode for print
        self.emit_byte(OpCode::OpPrint as u8)?;
        Ok(())
    }

    fn return_statement(&mut self) -> Result<(), CompilerError> {
        if self.compiler().function_type.is_script() {
            return Err(self.construct_token_error(false, "Can't return from top-level code."));
        }

        if self.match_curr_ty(TokenType::Semicolon)? {
            self.emit_return()
        } else {
            self.expression()?;
            self.consume(TokenType::Semicolon, "Expected ';' after return value.")?;
            self.emit_byte(OpCode::OpReturn as u8)
        }
    }
}
